---
// Simple timezone viewer component
---

<div class="time-viewer">
    <button class="toggle-button" id="toggle-button">
        <span class="toggle-time" id="toggle-time">12:00 PM</span>
        <span class="toggle-arrow" id="toggle-arrow">▼</span>
    </button>

    <div class="collapsible-content" id="collapsible-content">
        <div class="time-controls">
            <button class="time-btn" id="time-minus">-15min</button>
            <button class="calc-time" id="calc-time">Now ↻</button>
            <button class="time-btn" id="time-plus">+15min</button>
        </div>

        <div class="cities-grid" id="cities">
            <!-- Cities will be populated by JavaScript -->
        </div>

        <div class="controls-row">
            <input
                type="text"
                class="timezone-input"
                id="timezone-input"
                list="timezone-list"
                autocomplete="off"
            />
            <datalist id="timezone-list"></datalist>
        </div>
    </div>
</div>

<style is:global>
    .toggle-button {
        width: 100%;
        padding: 0.75rem 1rem;
        background: #ffffff;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: none;
        border: none;
    }

    .toggle-button:hover {
        background: #f8f9fa;
    }

    .toggle-time {
        font-size: 1rem;
        font-weight: 500;
        color: #212529;
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
            "Courier New", monospace;
    }

    .toggle-arrow {
        font-size: 0.75rem;
        color: #6c757d;
        transition: transform 0.2s ease;
    }

    .toggle-button.expanded .toggle-arrow {
        transform: rotate(180deg);
    }

    .time-viewer {
        max-width: 600px;
        font-family:
            system-ui,
            -apple-system,
            sans-serif;
        font-size: 1rem;
    }

    .collapsible-content {
        padding: 1rem;
        overflow: hidden;
        transition:
            max-height 0.3s ease,
            padding 0.3s ease;
    }

    .collapsible-content.collapsed {
        max-height: 0;
        padding: 0 1rem;
    }

    .time-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 1rem 0;
        justify-content: center;
    }

    .time-btn {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.2s;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
    }

    .time-btn:hover {
        background: #e9ecef;
    }

    .calc-time {
        font-size: 1rem;
        font-weight: 500;
        color: #212529;
        min-width: 120px;
        text-align: center;
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, "Courier New", monospace;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        padding: 0.5rem 1rem;
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.2s;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
    }

    .calc-time:hover {
        background: #e9ecef;
    }

    .controls-row {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        margin-bottom: 1rem;
    }

    .reset-button {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        padding: 0.5rem;
        font-size: 0.875rem;
        cursor: pointer;
        flex-shrink: 0;
    }

    .reset-button:hover {
        background: #e9ecef;
    }

    .cities-grid {
        display: grid;
        gap: 0;
    }

    .city-row {
        display: grid;
        grid-template-columns: auto 1fr auto 120px;
        align-items: center;
        padding: 0.75rem 1rem;
        transition: background-color 0.2s;
        gap: 1rem;
    }

    .city-row:last-child {
        border-bottom: none;
    }

    .city-row:hover {
        background: #f8f9fa;
    }

    .city-info {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .city-name {
        font-size: 1rem;
        font-weight: 500;
        color: #212529;
    }

    .city-offset {
        font-size: 0.875rem;
        color: #6c757d;
        font-weight: 400;
    }

    .city-icon {
        font-size: 1.25rem;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 1.5rem;
        height: 1.5rem;
    }

    .city-time {
        font-size: 1.125rem;
        font-weight: 500;
        color: #212529;
        text-align: right;
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
            "Courier New", monospace;
        line-height: 1;
    }

    /* Time of day colors - clean and simple */
    .city-row.morning {
        --city-color: #fd7e14; /* orange */
    }
    .city-row.day {
        --city-color: #198754; /* green */
    }
    .city-row.evening {
        --city-color: #dc3545; /* red */
    }
    .city-row.night {
        --city-color: #0d6efd; /* blue */
    }

    /* Time-specific colors for time display */
    .city-row.morning .city-time {
        color: #fd7e14;
    }
    .city-row.day .city-time {
        color: #198754;
    }
    .city-row.evening .city-time {
        color: #dc3545;
    }
    .city-row.night .city-time {
        color: #6c757d;
    }

    @media (max-width: 640px) {
        .time-viewer {
            margin: 0.5rem;
        }

        .toggle-button {
            padding: 0.5rem 0.75rem;
        }

        .toggle-time {
            font-size: 0.875rem;
        }

        .collapsible-content {
            padding: 0.75rem;
        }

        .collapsible-content.collapsed {
            padding: 0 0.75rem;
        }

        .city-row {
            grid-template-columns: auto 1fr auto auto;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
        }

        .city-name {
            font-size: 0.875rem;
        }

        .city-offset {
            font-size: 0.75rem;
        }

        .city-icon {
            font-size: 1rem;
            width: 1.25rem;
            height: 1.25rem;
        }

        .city-time {
            font-size: 1rem;
        }

        .time-controls {
            padding: 0.75rem 0;
            margin-bottom: 0.75rem;
            gap: 0.75rem;
        }

        .time-btn {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
        }

        .calc-time {
            font-size: 0.875rem;
            min-width: 100px;
        }
    }

    /* Table-like headers */
    .cities-grid::before {
        content: "";
        display: none;
    }

    .timezone-input {
        flex: 1;
        padding: 0.5rem;
        border: 1px solid #dee2e6;
        background: #ffffff;
    }

    .timezone-input:focus {
        outline: none;
        border-color: #0d6efd;
    }

    .city-row .remove-btn {
        background: none;
        border: none;
        color: #6c757d;
        cursor: pointer;
        padding: 0.25rem;
        font-size: 1rem;
        opacity: 1;
        transition: opacity 0.2s;
    }

    .city-row .remove-btn:hover {
        color: #dc3545;
    }

    /* Clean, readable typography */
    * {
        box-sizing: border-box;
    }
</style>

<script>
    function loadTimezones(): string[] {
        const stored = localStorage.getItem("timeview-timezones");
        return stored
            ? JSON.parse(stored)
            : ["Europe/London"];
    }

    function saveTimezones(timezones: string[]): void {
        localStorage.setItem("timeview-timezones", JSON.stringify(timezones));
    }

    function getTimezoneLabel(timezone: string): string {
        return timezone.split("/").pop()?.replace(/_/g, " ") || timezone;
    }

    class SimpleTimezoneViewer {
        private calcTimeDisplay: HTMLButtonElement;
        private timeMinusBtn: HTMLButtonElement;
        private timePlusBtn: HTMLButtonElement;
        private citiesContainer: HTMLDivElement;
        private toggleButton: HTMLButtonElement;
        private toggleTime: HTMLSpanElement;
        private collapsibleContent: HTMLDivElement;
        private timezoneInput: HTMLInputElement;
        private timezoneList: HTMLDataListElement;
        private offsetMinutes: number;
        private isExpanded: boolean;
        private timezones: string[];
        private updateInterval: number | null = null;
        private longPressInterval: number | null = null;
        private longPressTimeout: number | null = null;

        constructor() {
            this.calcTimeDisplay = document.getElementById("calc-time") as HTMLButtonElement;
            this.timeMinusBtn = document.getElementById("time-minus") as HTMLButtonElement;
            this.timePlusBtn = document.getElementById("time-plus") as HTMLButtonElement;
            this.citiesContainer = document.getElementById("cities") as HTMLDivElement;
            this.toggleButton = document.getElementById("toggle-button") as HTMLButtonElement;
            this.toggleTime = document.getElementById("toggle-time") as HTMLSpanElement;
            this.collapsibleContent = document.getElementById("collapsible-content") as HTMLDivElement;
            this.timezoneInput = document.getElementById("timezone-input") as HTMLInputElement;
            this.timezoneList = document.getElementById("timezone-list") as HTMLDataListElement;
            this.offsetMinutes = 0;
            this.isExpanded = false;
            this.timezones = loadTimezones();

            this.init();
        }

        init() {
            this.renderCities();
            this.populateTimezoneList();
            this.setupEventListeners();
            this.updateDisplay();
            this.updateToggleTime();
            // Start collapsed
            this.collapsibleContent.classList.add("collapsed");
            
            // Set up automatic updates every minute
            this.startAutoUpdate();
        }

        setupEventListeners() {
            // Toggle button
            this.toggleButton.addEventListener("click", () => {
                this.toggleCollapse();
            });

            // Time control button events with long press support
            this.setupLongPress(this.timeMinusBtn, () => {
                this.offsetMinutes -= 15;
                this.updateDisplay();
                this.updateToggleTime();
            });

            this.setupLongPress(this.timePlusBtn, () => {
                this.offsetMinutes += 15;
                this.updateDisplay();
                this.updateToggleTime();
            });

            // Reset button (calc-time display)
            this.calcTimeDisplay.addEventListener("click", () => {
                this.resetToNow();
            });

            // Timezone input
            this.timezoneInput.addEventListener("input", (e: Event) => {
                const target = e.target as HTMLInputElement;
                const value = target.value;
                if (Intl.supportedValuesOf("timeZone").includes(value)) {
                    this.addTimezone(value);
                    target.value = "";
                }
            });
        }

        toggleCollapse() {
            this.isExpanded = !this.isExpanded;

            if (this.isExpanded) {
                this.toggleButton.classList.add("expanded");
                this.collapsibleContent.classList.remove("collapsed");
            } else {
                this.toggleButton.classList.remove("expanded");
                this.collapsibleContent.classList.add("collapsed");
            }
        }

        startAutoUpdate(): void {
            // Clear any existing interval
            this.stopAutoUpdate();
            
            // Update every minute (60000 ms)
            this.updateInterval = window.setInterval(() => {
                // Only update if the slider is at "now" position (offset = 0)
                if (this.offsetMinutes === 0) {
                    this.updateDisplay();
                    this.updateToggleTime();
                }
            }, 60000);
        }

        stopAutoUpdate(): void {
            if (this.updateInterval !== null) {
                window.clearInterval(this.updateInterval);
                this.updateInterval = null;
            }
        }

        setupLongPress(button: HTMLButtonElement, action: () => void): void {
            let isPressed = false;
            
            const startLongPress = () => {
                isPressed = true;
                // Execute action immediately on first press
                action();
                
                // Start long press after 500ms delay
                this.longPressTimeout = window.setTimeout(() => {
                    if (isPressed) {
                        // Repeat action every 150ms while pressed
                        this.longPressInterval = window.setInterval(() => {
                            if (isPressed) {
                                action();
                            }
                        }, 150);
                    }
                }, 500);
            };
            
            const stopLongPress = () => {
                isPressed = false;
                this.stopLongPress();
            };
            
            // Mouse events
            button.addEventListener("mousedown", startLongPress);
            button.addEventListener("mouseup", stopLongPress);
            button.addEventListener("mouseleave", stopLongPress);
            
            // Touch events for mobile
            button.addEventListener("touchstart", startLongPress);
            button.addEventListener("touchend", stopLongPress);
            button.addEventListener("touchcancel", stopLongPress);
            
            // Prevent context menu on long press (mobile)
            button.addEventListener("contextmenu", (e) => e.preventDefault());
        }

        stopLongPress(): void {
            if (this.longPressTimeout !== null) {
                window.clearTimeout(this.longPressTimeout);
                this.longPressTimeout = null;
            }
            if (this.longPressInterval !== null) {
                window.clearInterval(this.longPressInterval);
                this.longPressInterval = null;
            }
        }

        destroy(): void {
            // Clean up when component is destroyed
            this.stopAutoUpdate();
            this.stopLongPress();
        }

        updateToggleTime() {
            // Show current local time in the toggle button
            const now = new Date();
            const offsetTime = new Date(now.getTime() + this.offsetMinutes * 60000);
            const timeString = offsetTime.toLocaleString("en-US", {
                weekday: "short",
                month: "short",
                day: "numeric",
                hour: "numeric",
                minute: "2-digit",
                hour12: true,
            });
            this.toggleTime.textContent = timeString;
        }

        resetToNow() {
            this.offsetMinutes = 0;
            this.updateDisplay();
            this.updateToggleTime();
        }


        formatOffset(minutes: number): string {
            if (minutes === 0) return "Now ↻";
            const hours = Math.abs(Math.floor(minutes / 60));
            const mins = Math.abs(minutes % 60);
            const sign = minutes >= 0 ? "+" : "-";

            return `${sign}${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')} ↻`;
        }

        getCityTime(timezone: string): string {
            const now = new Date();
            const offsetTime = new Date(now.getTime() + this.offsetMinutes * 60000);

            try {
                const timeString = offsetTime.toLocaleString("en-US", {
                    timeZone: timezone,
                    hour: "numeric",
                    minute: "2-digit",
                    hour12: true,
                });
                return timeString;
            } catch {
                return "12:00 AM";
            }
        }

        getTimeOfDay(timezone: string): string {
            const now = new Date();
            const offsetTime = new Date(now.getTime() + this.offsetMinutes * 60000);

            try {
                const hour = parseInt(
                    offsetTime.toLocaleString("en-US", {
                        timeZone: timezone,
                        hour: "numeric",
                        hour12: false,
                    })
                );

                if (hour >= 6 && hour < 12) return "morning";
                if (hour >= 12 && hour < 18) return "day";
                if (hour >= 18 && hour < 22) return "evening";
                return "night";
            } catch {
                return "day";
            }
        }

        getTimezoneOffset(timezone: string): string {
            try {
                const now = new Date();
                const localTime = new Date();
                const targetTime = new Date(
                    now.toLocaleString("en-US", { timeZone: timezone })
                );

                const diffHours = Math.round(
                    (targetTime.getTime() - localTime.getTime()) / (1000 * 60 * 60)
                );

                if (diffHours === 0) return "same time";
                const sign = diffHours > 0 ? "+" : "";
                return `${sign}${diffHours}h`;
            } catch {
                return "UTC";
            }
        }

        getTimezoneOffsetFormatted(timezone: string): string {
            try {
                const now = new Date();
                const formatter = new Intl.DateTimeFormat("en-US", {
                    timeZone: timezone,
                    timeZoneName: "shortOffset"
                });
                
                const parts = formatter.formatToParts(now);
                const offsetPart = parts.find(part => part.type === "timeZoneName");
                
                if (offsetPart && offsetPart.value !== "GMT") {
                    return offsetPart.value;
                }
                
                // Fallback method
                const localTime = new Date().getTime();
                const targetTime = new Date(now.toLocaleString("en-US", { timeZone: timezone })).getTime();
                const diffMinutes = Math.round((targetTime - localTime) / (1000 * 60));
                const diffHours = Math.floor(Math.abs(diffMinutes) / 60);
                const diffMins = Math.abs(diffMinutes) % 60;
                const sign = diffMinutes >= 0 ? "+" : "-";
                
                if (diffMinutes === 0) return "UTC+0";
                return `UTC${sign}${diffHours}${diffMins > 0 ? `:${diffMins.toString().padStart(2, '0')}` : ''}`;
            } catch {
                return "UTC";
            }
        }

        renderCities() {
            const html = this.timezones
                .map(
                    (timezone) => `
                <div class="city-row" data-timezone="${timezone}">
                    <button class="remove-btn" data-timezone="${timezone}">×</button>
                    <div class="city-info">
                        <div class="city-name">${getTimezoneLabel(timezone)}</div>
                        <div class="city-offset"></div>
                    </div>
                    <div class="city-icon"></div>
                    <div class="city-time"></div>
                </div>
            `
                )
                .join("");

            this.citiesContainer.innerHTML = html;
            this.setupRemoveButtons();
        }

        setupRemoveButtons(): void {
            this.citiesContainer.querySelectorAll(".remove-btn").forEach((btn) => {
                btn.addEventListener("click", (e: Event) => {
                    const target = e.target as HTMLButtonElement;
                    const timezone = target.getAttribute("data-timezone");
                    if (timezone) {
                        this.removeTimezone(timezone);
                    }
                });
            });
        }

        addTimezone(timezone: string): void {
            if (!this.timezones.includes(timezone)) {
                this.timezones.push(timezone);
                saveTimezones(this.timezones);
                this.renderCities();
                this.populateTimezoneList();
                this.updateDisplay();
            }
        }

        removeTimezone(timezone: string): void {
            this.timezones = this.timezones.filter((tz: string) => tz !== timezone);
            saveTimezones(this.timezones);
            this.renderCities();
            this.populateTimezoneList();
            this.updateDisplay();
        }

        populateTimezoneList() {
            const allTimezones = Intl.supportedValuesOf("timeZone");
            const options = allTimezones
                .filter((tz) => !this.timezones.includes(tz))
                .sort()
                .map((tz) => {
                    const offset = this.getTimezoneOffsetFormatted(tz);
                    return `<option value="${tz}">${getTimezoneLabel(tz)} ${offset} (${tz})</option>`;
                })
                .join("");

            this.timezoneList.innerHTML = options;
        }

        updateDisplay(): void {
            this.calcTimeDisplay.textContent = this.formatOffset(this.offsetMinutes);
            this.updateToggleTime();

            // Update each city
            const cityRows = this.citiesContainer.querySelectorAll(".city-row");
            cityRows.forEach((row) => {
                const htmlRow = row as HTMLElement;
                const timezone = htmlRow.dataset.timezone;
                if (!timezone) return;

                const timeElement = row.querySelector(".city-time");
                const offsetElement = row.querySelector(".city-offset");
                const iconElement = row.querySelector(".city-icon");

                if (timeElement) timeElement.textContent = this.getCityTime(timezone);
                if (offsetElement) offsetElement.textContent = this.getRelativeTimeText(timezone);

                // Update time of day class and icon
                const timeOfDay = this.getTimeOfDay(timezone);
                htmlRow.className = `city-row ${timeOfDay}`;
                if (iconElement) iconElement.textContent = this.getTimeIcon(timeOfDay);
            });
        }

        getRelativeTimeText(timezone: string): string {
            try {
                const now = new Date();
                const localTime = new Date();
                const targetTime = new Date(
                    now.toLocaleString("en-US", { timeZone: timezone })
                );

                const diffHours = Math.round(
                    (targetTime.getTime() - localTime.getTime()) / (1000 * 60 * 60)
                );
                const diffMinutes =
                    Math.round(
                        (targetTime.getTime() - localTime.getTime()) / (1000 * 60)
                    ) % 60;

                if (diffHours === 0 && diffMinutes === 0) return "Today, same time";

                let text = "Today, ";
                const absHours = Math.abs(diffHours);
                const absMinutes = Math.abs(diffMinutes);
                const direction =
                    diffHours > 0 || (diffHours === 0 && diffMinutes > 0)
                        ? "ahead"
                        : "behind";

                if (absHours > 0) {
                    text += `${absHours} hour${absHours !== 1 ? "s" : ""}`;
                    if (absMinutes > 0) {
                        text += ` ${absMinutes} minute${absMinutes !== 1 ? "s" : ""}`;
                    }
                } else if (absMinutes > 0) {
                    text += `${absMinutes} minute${absMinutes !== 1 ? "s" : ""}`;
                }

                return text + ` ${direction}`;
            } catch {
                return "Today";
            }
        }

        getTimeIcon(timeOfDay: string): string {
            switch (timeOfDay) {
                case "morning":
                    return "🌅";
                case "day":
                    return "☀️";
                case "evening":
                    return "🌇";
                case "night":
                    return "🌙";
                default:
                    return "☀️";
            }
        }
    }

    // Initialize when DOM is ready
    let timezoneViewer: SimpleTimezoneViewer;
    
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
            timezoneViewer = new SimpleTimezoneViewer();
        });
    } else {
        timezoneViewer = new SimpleTimezoneViewer();
    }

    // Clean up on page unload
    window.addEventListener("beforeunload", () => {
        if (timezoneViewer) {
            timezoneViewer.destroy();
        }
    });
</script>
